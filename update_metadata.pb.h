// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: update_metadata.proto

#ifndef PROTOBUF_update_5fmetadata_2eproto__INCLUDED
#define PROTOBUF_update_5fmetadata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace chromeos_update_engine {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_update_5fmetadata_2eproto();
void protobuf_AssignDesc_update_5fmetadata_2eproto();
void protobuf_ShutdownFile_update_5fmetadata_2eproto();

class DeltaArchiveManifest;
class Extent;
class ImageInfo;
class InstallOperation;
class PartitionInfo;
class PartitionUpdate;
class Signatures;
class Signatures_Signature;

enum InstallOperation_Type {
  InstallOperation_Type_REPLACE = 0,
  InstallOperation_Type_REPLACE_BZ = 1,
  InstallOperation_Type_MOVE = 2,
  InstallOperation_Type_BSDIFF = 3,
  InstallOperation_Type_SOURCE_COPY = 4,
  InstallOperation_Type_SOURCE_BSDIFF = 5,
  InstallOperation_Type_REPLACE_XZ = 8,
  InstallOperation_Type_ZERO = 6,
  InstallOperation_Type_DISCARD = 7,
  InstallOperation_Type_BROTLI_BSDIFF = 10,
  InstallOperation_Type_PUFFDIFF = 9
};
bool InstallOperation_Type_IsValid(int value);
const InstallOperation_Type InstallOperation_Type_Type_MIN = InstallOperation_Type_REPLACE;
const InstallOperation_Type InstallOperation_Type_Type_MAX = InstallOperation_Type_BROTLI_BSDIFF;
const int InstallOperation_Type_Type_ARRAYSIZE = InstallOperation_Type_Type_MAX + 1;

// ===================================================================

class Extent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Extent) */ {
 public:
  Extent();
  virtual ~Extent();

  Extent(const Extent& from);

  inline Extent& operator=(const Extent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Extent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Extent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Extent* other);

  // implements Message ----------------------------------------------

  inline Extent* New() const { return New(NULL); }

  Extent* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Extent& from);
  void MergeFrom(const Extent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start_block = 1;
  bool has_start_block() const;
  void clear_start_block();
  static const int kStartBlockFieldNumber = 1;
  ::google::protobuf::uint64 start_block() const;
  void set_start_block(::google::protobuf::uint64 value);

  // optional uint64 num_blocks = 2;
  bool has_num_blocks() const;
  void clear_num_blocks();
  static const int kNumBlocksFieldNumber = 2;
  ::google::protobuf::uint64 num_blocks() const;
  void set_num_blocks(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Extent)
 private:
  inline void set_has_start_block();
  inline void clear_has_start_block();
  inline void set_has_num_blocks();
  inline void clear_has_num_blocks();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_block_;
  ::google::protobuf::uint64 num_blocks_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static Extent* default_instance_;
};
// -------------------------------------------------------------------

class Signatures_Signature : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures.Signature) */ {
 public:
  Signatures_Signature();
  virtual ~Signatures_Signature();

  Signatures_Signature(const Signatures_Signature& from);

  inline Signatures_Signature& operator=(const Signatures_Signature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Signatures_Signature& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Signatures_Signature* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Signatures_Signature* other);

  // implements Message ----------------------------------------------

  inline Signatures_Signature* New() const { return New(NULL); }

  Signatures_Signature* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Signatures_Signature& from);
  void MergeFrom(const Signatures_Signature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures_Signature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures.Signature)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint32 version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static Signatures_Signature* default_instance_;
};
// -------------------------------------------------------------------

class Signatures : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.Signatures) */ {
 public:
  Signatures();
  virtual ~Signatures();

  Signatures(const Signatures& from);

  inline Signatures& operator=(const Signatures& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const Signatures& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Signatures* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Signatures* other);

  // implements Message ----------------------------------------------

  inline Signatures* New() const { return New(NULL); }

  Signatures* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Signatures& from);
  void MergeFrom(const Signatures& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Signatures* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Signatures_Signature Signature;

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 1;
  const ::chromeos_update_engine::Signatures_Signature& signatures(int index) const;
  ::chromeos_update_engine::Signatures_Signature* mutable_signatures(int index);
  ::chromeos_update_engine::Signatures_Signature* add_signatures();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_signatures();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      signatures() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.Signatures)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > signatures_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static Signatures* default_instance_;
};
// -------------------------------------------------------------------

class PartitionInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionInfo) */ {
 public:
  PartitionInfo();
  virtual ~PartitionInfo();

  PartitionInfo(const PartitionInfo& from);

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PartitionInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PartitionInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PartitionInfo* other);

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const { return New(NULL); }

  PartitionInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PartitionInfo& from);
  void MergeFrom(const PartitionInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 size = 1;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 1;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // optional bytes hash = 2;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionInfo)
 private:
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_hash();
  inline void clear_has_hash();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static PartitionInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.ImageInfo) */ {
 public:
  ImageInfo();
  virtual ~ImageInfo();

  ImageInfo(const ImageInfo& from);

  inline ImageInfo& operator=(const ImageInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const ImageInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ImageInfo* other);

  // implements Message ----------------------------------------------

  inline ImageInfo* New() const { return New(NULL); }

  ImageInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageInfo& from);
  void MergeFrom(const ImageInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ImageInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string board = 1;
  bool has_board() const;
  void clear_board();
  static const int kBoardFieldNumber = 1;
  const ::std::string& board() const;
  void set_board(const ::std::string& value);
  void set_board(const char* value);
  void set_board(const char* value, size_t size);
  ::std::string* mutable_board();
  ::std::string* release_board();
  void set_allocated_board(::std::string* board);

  // optional string key = 2;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string channel = 3;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  const ::std::string& channel() const;
  void set_channel(const ::std::string& value);
  void set_channel(const char* value);
  void set_channel(const char* value, size_t size);
  ::std::string* mutable_channel();
  ::std::string* release_channel();
  void set_allocated_channel(::std::string* channel);

  // optional string version = 4;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 4;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional string build_channel = 5;
  bool has_build_channel() const;
  void clear_build_channel();
  static const int kBuildChannelFieldNumber = 5;
  const ::std::string& build_channel() const;
  void set_build_channel(const ::std::string& value);
  void set_build_channel(const char* value);
  void set_build_channel(const char* value, size_t size);
  ::std::string* mutable_build_channel();
  ::std::string* release_build_channel();
  void set_allocated_build_channel(::std::string* build_channel);

  // optional string build_version = 6;
  bool has_build_version() const;
  void clear_build_version();
  static const int kBuildVersionFieldNumber = 6;
  const ::std::string& build_version() const;
  void set_build_version(const ::std::string& value);
  void set_build_version(const char* value);
  void set_build_version(const char* value, size_t size);
  ::std::string* mutable_build_version();
  ::std::string* release_build_version();
  void set_allocated_build_version(::std::string* build_version);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.ImageInfo)
 private:
  inline void set_has_board();
  inline void clear_has_board();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_build_channel();
  inline void clear_has_build_channel();
  inline void set_has_build_version();
  inline void clear_has_build_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr board_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr channel_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr build_channel_;
  ::google::protobuf::internal::ArenaStringPtr build_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static ImageInfo* default_instance_;
};
// -------------------------------------------------------------------

class InstallOperation : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.InstallOperation) */ {
 public:
  InstallOperation();
  virtual ~InstallOperation();

  InstallOperation(const InstallOperation& from);

  inline InstallOperation& operator=(const InstallOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const InstallOperation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const InstallOperation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(InstallOperation* other);

  // implements Message ----------------------------------------------

  inline InstallOperation* New() const { return New(NULL); }

  InstallOperation* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const InstallOperation& from);
  void MergeFrom(const InstallOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InstallOperation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef InstallOperation_Type Type;
  static const Type REPLACE =
    InstallOperation_Type_REPLACE;
  static const Type REPLACE_BZ =
    InstallOperation_Type_REPLACE_BZ;
  static const Type MOVE =
    InstallOperation_Type_MOVE;
  static const Type BSDIFF =
    InstallOperation_Type_BSDIFF;
  static const Type SOURCE_COPY =
    InstallOperation_Type_SOURCE_COPY;
  static const Type SOURCE_BSDIFF =
    InstallOperation_Type_SOURCE_BSDIFF;
  static const Type REPLACE_XZ =
    InstallOperation_Type_REPLACE_XZ;
  static const Type ZERO =
    InstallOperation_Type_ZERO;
  static const Type DISCARD =
    InstallOperation_Type_DISCARD;
  static const Type BROTLI_BSDIFF =
    InstallOperation_Type_BROTLI_BSDIFF;
  static const Type PUFFDIFF =
    InstallOperation_Type_PUFFDIFF;
  static inline bool Type_IsValid(int value) {
    return InstallOperation_Type_IsValid(value);
  }
  static const Type Type_MIN =
    InstallOperation_Type_Type_MIN;
  static const Type Type_MAX =
    InstallOperation_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    InstallOperation_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required .chromeos_update_engine.InstallOperation.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::chromeos_update_engine::InstallOperation_Type type() const;
  void set_type(::chromeos_update_engine::InstallOperation_Type value);

  // optional uint32 data_offset = 2;
  bool has_data_offset() const;
  void clear_data_offset();
  static const int kDataOffsetFieldNumber = 2;
  ::google::protobuf::uint32 data_offset() const;
  void set_data_offset(::google::protobuf::uint32 value);

  // optional uint32 data_length = 3;
  bool has_data_length() const;
  void clear_data_length();
  static const int kDataLengthFieldNumber = 3;
  ::google::protobuf::uint32 data_length() const;
  void set_data_length(::google::protobuf::uint32 value);

  // repeated .chromeos_update_engine.Extent src_extents = 4;
  int src_extents_size() const;
  void clear_src_extents();
  static const int kSrcExtentsFieldNumber = 4;
  const ::chromeos_update_engine::Extent& src_extents(int index) const;
  ::chromeos_update_engine::Extent* mutable_src_extents(int index);
  ::chromeos_update_engine::Extent* add_src_extents();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_src_extents();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      src_extents() const;

  // optional uint64 src_length = 5;
  bool has_src_length() const;
  void clear_src_length();
  static const int kSrcLengthFieldNumber = 5;
  ::google::protobuf::uint64 src_length() const;
  void set_src_length(::google::protobuf::uint64 value);

  // repeated .chromeos_update_engine.Extent dst_extents = 6;
  int dst_extents_size() const;
  void clear_dst_extents();
  static const int kDstExtentsFieldNumber = 6;
  const ::chromeos_update_engine::Extent& dst_extents(int index) const;
  ::chromeos_update_engine::Extent* mutable_dst_extents(int index);
  ::chromeos_update_engine::Extent* add_dst_extents();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
      mutable_dst_extents();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
      dst_extents() const;

  // optional uint64 dst_length = 7;
  bool has_dst_length() const;
  void clear_dst_length();
  static const int kDstLengthFieldNumber = 7;
  ::google::protobuf::uint64 dst_length() const;
  void set_dst_length(::google::protobuf::uint64 value);

  // optional bytes data_sha256_hash = 8;
  bool has_data_sha256_hash() const;
  void clear_data_sha256_hash();
  static const int kDataSha256HashFieldNumber = 8;
  const ::std::string& data_sha256_hash() const;
  void set_data_sha256_hash(const ::std::string& value);
  void set_data_sha256_hash(const char* value);
  void set_data_sha256_hash(const void* value, size_t size);
  ::std::string* mutable_data_sha256_hash();
  ::std::string* release_data_sha256_hash();
  void set_allocated_data_sha256_hash(::std::string* data_sha256_hash);

  // optional bytes src_sha256_hash = 9;
  bool has_src_sha256_hash() const;
  void clear_src_sha256_hash();
  static const int kSrcSha256HashFieldNumber = 9;
  const ::std::string& src_sha256_hash() const;
  void set_src_sha256_hash(const ::std::string& value);
  void set_src_sha256_hash(const char* value);
  void set_src_sha256_hash(const void* value, size_t size);
  ::std::string* mutable_src_sha256_hash();
  ::std::string* release_src_sha256_hash();
  void set_allocated_src_sha256_hash(::std::string* src_sha256_hash);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.InstallOperation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data_offset();
  inline void clear_has_data_offset();
  inline void set_has_data_length();
  inline void clear_has_data_length();
  inline void set_has_src_length();
  inline void clear_has_src_length();
  inline void set_has_dst_length();
  inline void clear_has_dst_length();
  inline void set_has_data_sha256_hash();
  inline void clear_has_data_sha256_hash();
  inline void set_has_src_sha256_hash();
  inline void clear_has_src_sha256_hash();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 data_offset_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > src_extents_;
  ::google::protobuf::uint64 src_length_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent > dst_extents_;
  ::google::protobuf::uint64 dst_length_;
  ::google::protobuf::internal::ArenaStringPtr data_sha256_hash_;
  ::google::protobuf::internal::ArenaStringPtr src_sha256_hash_;
  ::google::protobuf::uint32 data_length_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static InstallOperation* default_instance_;
};
// -------------------------------------------------------------------

class PartitionUpdate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.PartitionUpdate) */ {
 public:
  PartitionUpdate();
  virtual ~PartitionUpdate();

  PartitionUpdate(const PartitionUpdate& from);

  inline PartitionUpdate& operator=(const PartitionUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const PartitionUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PartitionUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PartitionUpdate* other);

  // implements Message ----------------------------------------------

  inline PartitionUpdate* New() const { return New(NULL); }

  PartitionUpdate* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PartitionUpdate& from);
  void MergeFrom(const PartitionUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PartitionUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string partition_name = 1;
  bool has_partition_name() const;
  void clear_partition_name();
  static const int kPartitionNameFieldNumber = 1;
  const ::std::string& partition_name() const;
  void set_partition_name(const ::std::string& value);
  void set_partition_name(const char* value);
  void set_partition_name(const char* value, size_t size);
  ::std::string* mutable_partition_name();
  ::std::string* release_partition_name();
  void set_allocated_partition_name(::std::string* partition_name);

  // optional bool run_postinstall = 2;
  bool has_run_postinstall() const;
  void clear_run_postinstall();
  static const int kRunPostinstallFieldNumber = 2;
  bool run_postinstall() const;
  void set_run_postinstall(bool value);

  // optional string postinstall_path = 3;
  bool has_postinstall_path() const;
  void clear_postinstall_path();
  static const int kPostinstallPathFieldNumber = 3;
  const ::std::string& postinstall_path() const;
  void set_postinstall_path(const ::std::string& value);
  void set_postinstall_path(const char* value);
  void set_postinstall_path(const char* value, size_t size);
  ::std::string* mutable_postinstall_path();
  ::std::string* release_postinstall_path();
  void set_allocated_postinstall_path(::std::string* postinstall_path);

  // optional string filesystem_type = 4;
  bool has_filesystem_type() const;
  void clear_filesystem_type();
  static const int kFilesystemTypeFieldNumber = 4;
  const ::std::string& filesystem_type() const;
  void set_filesystem_type(const ::std::string& value);
  void set_filesystem_type(const char* value);
  void set_filesystem_type(const char* value, size_t size);
  ::std::string* mutable_filesystem_type();
  ::std::string* release_filesystem_type();
  void set_allocated_filesystem_type(::std::string* filesystem_type);

  // repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
  int new_partition_signature_size() const;
  void clear_new_partition_signature();
  static const int kNewPartitionSignatureFieldNumber = 5;
  const ::chromeos_update_engine::Signatures_Signature& new_partition_signature(int index) const;
  ::chromeos_update_engine::Signatures_Signature* mutable_new_partition_signature(int index);
  ::chromeos_update_engine::Signatures_Signature* add_new_partition_signature();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
      mutable_new_partition_signature();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
      new_partition_signature() const;

  // optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
  bool has_old_partition_info() const;
  void clear_old_partition_info();
  static const int kOldPartitionInfoFieldNumber = 6;
  const ::chromeos_update_engine::PartitionInfo& old_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* release_old_partition_info();
  void set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info);

  // optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
  bool has_new_partition_info() const;
  void clear_new_partition_info();
  static const int kNewPartitionInfoFieldNumber = 7;
  const ::chromeos_update_engine::PartitionInfo& new_partition_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* release_new_partition_info();
  void set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info);

  // repeated .chromeos_update_engine.InstallOperation operations = 8;
  int operations_size() const;
  void clear_operations();
  static const int kOperationsFieldNumber = 8;
  const ::chromeos_update_engine::InstallOperation& operations(int index) const;
  ::chromeos_update_engine::InstallOperation* mutable_operations(int index);
  ::chromeos_update_engine::InstallOperation* add_operations();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_operations();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      operations() const;

  // optional bool postinstall_optional = 9;
  bool has_postinstall_optional() const;
  void clear_postinstall_optional();
  static const int kPostinstallOptionalFieldNumber = 9;
  bool postinstall_optional() const;
  void set_postinstall_optional(bool value);

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.PartitionUpdate)
 private:
  inline void set_has_partition_name();
  inline void clear_has_partition_name();
  inline void set_has_run_postinstall();
  inline void clear_has_run_postinstall();
  inline void set_has_postinstall_path();
  inline void clear_has_postinstall_path();
  inline void set_has_filesystem_type();
  inline void clear_has_filesystem_type();
  inline void set_has_old_partition_info();
  inline void clear_has_old_partition_info();
  inline void set_has_new_partition_info();
  inline void clear_has_new_partition_info();
  inline void set_has_postinstall_optional();
  inline void clear_has_postinstall_optional();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr partition_name_;
  ::google::protobuf::internal::ArenaStringPtr postinstall_path_;
  ::google::protobuf::internal::ArenaStringPtr filesystem_type_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature > new_partition_signature_;
  ::chromeos_update_engine::PartitionInfo* old_partition_info_;
  ::chromeos_update_engine::PartitionInfo* new_partition_info_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > operations_;
  bool run_postinstall_;
  bool postinstall_optional_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static PartitionUpdate* default_instance_;
};
// -------------------------------------------------------------------

class DeltaArchiveManifest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:chromeos_update_engine.DeltaArchiveManifest) */ {
 public:
  DeltaArchiveManifest();
  virtual ~DeltaArchiveManifest();

  DeltaArchiveManifest(const DeltaArchiveManifest& from);

  inline DeltaArchiveManifest& operator=(const DeltaArchiveManifest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_.GetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  inline ::std::string* mutable_unknown_fields() {
    return _unknown_fields_.MutableNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }

  static const DeltaArchiveManifest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DeltaArchiveManifest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DeltaArchiveManifest* other);

  // implements Message ----------------------------------------------

  inline DeltaArchiveManifest* New() const { return New(NULL); }

  DeltaArchiveManifest* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DeltaArchiveManifest& from);
  void MergeFrom(const DeltaArchiveManifest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DeltaArchiveManifest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chromeos_update_engine.InstallOperation install_operations = 1;
  int install_operations_size() const;
  void clear_install_operations();
  static const int kInstallOperationsFieldNumber = 1;
  const ::chromeos_update_engine::InstallOperation& install_operations(int index) const;
  ::chromeos_update_engine::InstallOperation* mutable_install_operations(int index);
  ::chromeos_update_engine::InstallOperation* add_install_operations();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_install_operations();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      install_operations() const;

  // repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;
  int kernel_install_operations_size() const;
  void clear_kernel_install_operations();
  static const int kKernelInstallOperationsFieldNumber = 2;
  const ::chromeos_update_engine::InstallOperation& kernel_install_operations(int index) const;
  ::chromeos_update_engine::InstallOperation* mutable_kernel_install_operations(int index);
  ::chromeos_update_engine::InstallOperation* add_kernel_install_operations();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
      mutable_kernel_install_operations();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
      kernel_install_operations() const;

  // optional uint32 block_size = 3 [default = 4096];
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 3;
  ::google::protobuf::uint32 block_size() const;
  void set_block_size(::google::protobuf::uint32 value);

  // optional uint64 signatures_offset = 4;
  bool has_signatures_offset() const;
  void clear_signatures_offset();
  static const int kSignaturesOffsetFieldNumber = 4;
  ::google::protobuf::uint64 signatures_offset() const;
  void set_signatures_offset(::google::protobuf::uint64 value);

  // optional uint64 signatures_size = 5;
  bool has_signatures_size() const;
  void clear_signatures_size();
  static const int kSignaturesSizeFieldNumber = 5;
  ::google::protobuf::uint64 signatures_size() const;
  void set_signatures_size(::google::protobuf::uint64 value);

  // optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;
  bool has_old_kernel_info() const;
  void clear_old_kernel_info();
  static const int kOldKernelInfoFieldNumber = 6;
  const ::chromeos_update_engine::PartitionInfo& old_kernel_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_old_kernel_info();
  ::chromeos_update_engine::PartitionInfo* release_old_kernel_info();
  void set_allocated_old_kernel_info(::chromeos_update_engine::PartitionInfo* old_kernel_info);

  // optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;
  bool has_new_kernel_info() const;
  void clear_new_kernel_info();
  static const int kNewKernelInfoFieldNumber = 7;
  const ::chromeos_update_engine::PartitionInfo& new_kernel_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_new_kernel_info();
  ::chromeos_update_engine::PartitionInfo* release_new_kernel_info();
  void set_allocated_new_kernel_info(::chromeos_update_engine::PartitionInfo* new_kernel_info);

  // optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;
  bool has_old_rootfs_info() const;
  void clear_old_rootfs_info();
  static const int kOldRootfsInfoFieldNumber = 8;
  const ::chromeos_update_engine::PartitionInfo& old_rootfs_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_old_rootfs_info();
  ::chromeos_update_engine::PartitionInfo* release_old_rootfs_info();
  void set_allocated_old_rootfs_info(::chromeos_update_engine::PartitionInfo* old_rootfs_info);

  // optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;
  bool has_new_rootfs_info() const;
  void clear_new_rootfs_info();
  static const int kNewRootfsInfoFieldNumber = 9;
  const ::chromeos_update_engine::PartitionInfo& new_rootfs_info() const;
  ::chromeos_update_engine::PartitionInfo* mutable_new_rootfs_info();
  ::chromeos_update_engine::PartitionInfo* release_new_rootfs_info();
  void set_allocated_new_rootfs_info(::chromeos_update_engine::PartitionInfo* new_rootfs_info);

  // optional .chromeos_update_engine.ImageInfo old_image_info = 10;
  bool has_old_image_info() const;
  void clear_old_image_info();
  static const int kOldImageInfoFieldNumber = 10;
  const ::chromeos_update_engine::ImageInfo& old_image_info() const;
  ::chromeos_update_engine::ImageInfo* mutable_old_image_info();
  ::chromeos_update_engine::ImageInfo* release_old_image_info();
  void set_allocated_old_image_info(::chromeos_update_engine::ImageInfo* old_image_info);

  // optional .chromeos_update_engine.ImageInfo new_image_info = 11;
  bool has_new_image_info() const;
  void clear_new_image_info();
  static const int kNewImageInfoFieldNumber = 11;
  const ::chromeos_update_engine::ImageInfo& new_image_info() const;
  ::chromeos_update_engine::ImageInfo* mutable_new_image_info();
  ::chromeos_update_engine::ImageInfo* release_new_image_info();
  void set_allocated_new_image_info(::chromeos_update_engine::ImageInfo* new_image_info);

  // optional uint32 minor_version = 12 [default = 0];
  bool has_minor_version() const;
  void clear_minor_version();
  static const int kMinorVersionFieldNumber = 12;
  ::google::protobuf::uint32 minor_version() const;
  void set_minor_version(::google::protobuf::uint32 value);

  // repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 13;
  const ::chromeos_update_engine::PartitionUpdate& partitions(int index) const;
  ::chromeos_update_engine::PartitionUpdate* mutable_partitions(int index);
  ::chromeos_update_engine::PartitionUpdate* add_partitions();
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
      mutable_partitions();
  const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
      partitions() const;

  // @@protoc_insertion_point(class_scope:chromeos_update_engine.DeltaArchiveManifest)
 private:
  inline void set_has_block_size();
  inline void clear_has_block_size();
  inline void set_has_signatures_offset();
  inline void clear_has_signatures_offset();
  inline void set_has_signatures_size();
  inline void clear_has_signatures_size();
  inline void set_has_old_kernel_info();
  inline void clear_has_old_kernel_info();
  inline void set_has_new_kernel_info();
  inline void clear_has_new_kernel_info();
  inline void set_has_old_rootfs_info();
  inline void clear_has_old_rootfs_info();
  inline void set_has_new_rootfs_info();
  inline void clear_has_new_rootfs_info();
  inline void set_has_old_image_info();
  inline void clear_has_old_image_info();
  inline void set_has_new_image_info();
  inline void clear_has_new_image_info();
  inline void set_has_minor_version();
  inline void clear_has_minor_version();

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > install_operations_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation > kernel_install_operations_;
  ::google::protobuf::uint64 signatures_offset_;
  ::google::protobuf::uint64 signatures_size_;
  ::chromeos_update_engine::PartitionInfo* old_kernel_info_;
  ::chromeos_update_engine::PartitionInfo* new_kernel_info_;
  ::google::protobuf::uint32 block_size_;
  ::google::protobuf::uint32 minor_version_;
  ::chromeos_update_engine::PartitionInfo* old_rootfs_info_;
  ::chromeos_update_engine::PartitionInfo* new_rootfs_info_;
  ::chromeos_update_engine::ImageInfo* old_image_info_;
  ::chromeos_update_engine::ImageInfo* new_image_info_;
  ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate > partitions_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_update_5fmetadata_2eproto();
  #endif
  friend void protobuf_AssignDesc_update_5fmetadata_2eproto();
  friend void protobuf_ShutdownFile_update_5fmetadata_2eproto();

  void InitAsDefaultInstance();
  static DeltaArchiveManifest* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Extent

// optional uint64 start_block = 1;
inline bool Extent::has_start_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extent::set_has_start_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Extent::clear_has_start_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Extent::clear_start_block() {
  start_block_ = GOOGLE_ULONGLONG(0);
  clear_has_start_block();
}
inline ::google::protobuf::uint64 Extent::start_block() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.start_block)
  return start_block_;
}
inline void Extent::set_start_block(::google::protobuf::uint64 value) {
  set_has_start_block();
  start_block_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.start_block)
}

// optional uint64 num_blocks = 2;
inline bool Extent::has_num_blocks() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extent::set_has_num_blocks() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Extent::clear_has_num_blocks() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Extent::clear_num_blocks() {
  num_blocks_ = GOOGLE_ULONGLONG(0);
  clear_has_num_blocks();
}
inline ::google::protobuf::uint64 Extent::num_blocks() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Extent.num_blocks)
  return num_blocks_;
}
inline void Extent::set_num_blocks(::google::protobuf::uint64 value) {
  set_has_num_blocks();
  num_blocks_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Extent.num_blocks)
}

// -------------------------------------------------------------------

// Signatures_Signature

// optional uint32 version = 1;
inline bool Signatures_Signature::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signatures_Signature::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Signatures_Signature::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Signatures_Signature::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Signatures_Signature::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.version)
  return version_;
}
inline void Signatures_Signature::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.version)
}

// optional bytes data = 2;
inline bool Signatures_Signature::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signatures_Signature::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Signatures_Signature::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Signatures_Signature::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Signatures_Signature::data() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.Signature.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signatures_Signature::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.Signatures.Signature.data)
}
inline void Signatures_Signature::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.Signatures.Signature.data)
}
inline ::std::string* Signatures_Signature::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.Signature.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Signatures_Signature::release_data() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.Signatures.Signature.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Signatures_Signature::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.Signatures.Signature.data)
}

// -------------------------------------------------------------------

// Signatures

// repeated .chromeos_update_engine.Signatures.Signature signatures = 1;
inline int Signatures::signatures_size() const {
  return signatures_.size();
}
inline void Signatures::clear_signatures() {
  signatures_.Clear();
}
inline const ::chromeos_update_engine::Signatures_Signature& Signatures::signatures(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.Signatures.signatures)
  return signatures_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.Signatures.signatures)
  return signatures_.Mutable(index);
}
inline ::chromeos_update_engine::Signatures_Signature* Signatures::add_signatures() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.Signatures.signatures)
  return signatures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
Signatures::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.Signatures.signatures)
  return &signatures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
Signatures::signatures() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.Signatures.signatures)
  return signatures_;
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint64 size = 1;
inline bool PartitionInfo::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionInfo::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 PartitionInfo::size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.size)
  return size_;
}
inline void PartitionInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.size)
}

// optional bytes hash = 2;
inline bool PartitionInfo::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionInfo::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionInfo::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionInfo::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hash();
}
inline const ::std::string& PartitionInfo::hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionInfo.hash)
  return hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_hash(const ::std::string& value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(const char* value) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionInfo.hash)
}
inline void PartitionInfo::set_hash(const void* value, size_t size) {
  set_has_hash();
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionInfo.hash)
}
inline ::std::string* PartitionInfo::mutable_hash() {
  set_has_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionInfo.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionInfo::release_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionInfo.hash)
  clear_has_hash();
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    set_has_hash();
  } else {
    clear_has_hash();
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionInfo.hash)
}

// -------------------------------------------------------------------

// ImageInfo

// optional string board = 1;
inline bool ImageInfo::has_board() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageInfo::set_has_board() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageInfo::clear_has_board() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageInfo::clear_board() {
  board_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_board();
}
inline const ::std::string& ImageInfo::board() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.board)
  return board_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_board(const ::std::string& value) {
  set_has_board();
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.board)
}
inline void ImageInfo::set_board(const char* value) {
  set_has_board();
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.board)
}
inline void ImageInfo::set_board(const char* value, size_t size) {
  set_has_board();
  board_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.board)
}
inline ::std::string* ImageInfo::mutable_board() {
  set_has_board();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.board)
  return board_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_board() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.board)
  clear_has_board();
  return board_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_board(::std::string* board) {
  if (board != NULL) {
    set_has_board();
  } else {
    clear_has_board();
  }
  board_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), board);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.board)
}

// optional string key = 2;
inline bool ImageInfo::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageInfo::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageInfo::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ImageInfo::key() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.key)
}
inline void ImageInfo::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.key)
}
inline void ImageInfo::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.key)
}
inline ::std::string* ImageInfo::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_key() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.key)
}

// optional string channel = 3;
inline bool ImageInfo::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageInfo::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageInfo::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageInfo::clear_channel() {
  channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel();
}
inline const ::std::string& ImageInfo::channel() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.channel)
  return channel_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_channel(const ::std::string& value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.channel)
}
inline void ImageInfo::set_channel(const char* value) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.channel)
}
inline void ImageInfo::set_channel(const char* value, size_t size) {
  set_has_channel();
  channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.channel)
}
inline ::std::string* ImageInfo::mutable_channel() {
  set_has_channel();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.channel)
  return channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_channel() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.channel)
  clear_has_channel();
  return channel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_channel(::std::string* channel) {
  if (channel != NULL) {
    set_has_channel();
  } else {
    clear_has_channel();
  }
  channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.channel)
}

// optional string version = 4;
inline bool ImageInfo::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageInfo::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& ImageInfo::version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.version)
}
inline void ImageInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.version)
}
inline void ImageInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.version)
}
inline ::std::string* ImageInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.version)
}

// optional string build_channel = 5;
inline bool ImageInfo::has_build_channel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageInfo::set_has_build_channel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageInfo::clear_has_build_channel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageInfo::clear_build_channel() {
  build_channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_channel();
}
inline const ::std::string& ImageInfo::build_channel() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.build_channel)
  return build_channel_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_build_channel(const ::std::string& value) {
  set_has_build_channel();
  build_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.build_channel)
}
inline void ImageInfo::set_build_channel(const char* value) {
  set_has_build_channel();
  build_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.build_channel)
}
inline void ImageInfo::set_build_channel(const char* value, size_t size) {
  set_has_build_channel();
  build_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.build_channel)
}
inline ::std::string* ImageInfo::mutable_build_channel() {
  set_has_build_channel();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.build_channel)
  return build_channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_build_channel() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.build_channel)
  clear_has_build_channel();
  return build_channel_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_build_channel(::std::string* build_channel) {
  if (build_channel != NULL) {
    set_has_build_channel();
  } else {
    clear_has_build_channel();
  }
  build_channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_channel);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.build_channel)
}

// optional string build_version = 6;
inline bool ImageInfo::has_build_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageInfo::set_has_build_version() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageInfo::clear_has_build_version() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageInfo::clear_build_version() {
  build_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_version();
}
inline const ::std::string& ImageInfo::build_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.ImageInfo.build_version)
  return build_version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_build_version(const ::std::string& value) {
  set_has_build_version();
  build_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.ImageInfo.build_version)
}
inline void ImageInfo::set_build_version(const char* value) {
  set_has_build_version();
  build_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.ImageInfo.build_version)
}
inline void ImageInfo::set_build_version(const char* value, size_t size) {
  set_has_build_version();
  build_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.ImageInfo.build_version)
}
inline ::std::string* ImageInfo::mutable_build_version() {
  set_has_build_version();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.ImageInfo.build_version)
  return build_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ImageInfo::release_build_version() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.ImageInfo.build_version)
  clear_has_build_version();
  return build_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ImageInfo::set_allocated_build_version(::std::string* build_version) {
  if (build_version != NULL) {
    set_has_build_version();
  } else {
    clear_has_build_version();
  }
  build_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_version);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.ImageInfo.build_version)
}

// -------------------------------------------------------------------

// InstallOperation

// required .chromeos_update_engine.InstallOperation.Type type = 1;
inline bool InstallOperation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallOperation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstallOperation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstallOperation::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::chromeos_update_engine::InstallOperation_Type InstallOperation::type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.type)
  return static_cast< ::chromeos_update_engine::InstallOperation_Type >(type_);
}
inline void InstallOperation::set_type(::chromeos_update_engine::InstallOperation_Type value) {
  assert(::chromeos_update_engine::InstallOperation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.type)
}

// optional uint32 data_offset = 2;
inline bool InstallOperation::has_data_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallOperation::set_has_data_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstallOperation::clear_has_data_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstallOperation::clear_data_offset() {
  data_offset_ = 0u;
  clear_has_data_offset();
}
inline ::google::protobuf::uint32 InstallOperation::data_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_offset)
  return data_offset_;
}
inline void InstallOperation::set_data_offset(::google::protobuf::uint32 value) {
  set_has_data_offset();
  data_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_offset)
}

// optional uint32 data_length = 3;
inline bool InstallOperation::has_data_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstallOperation::set_has_data_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstallOperation::clear_has_data_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstallOperation::clear_data_length() {
  data_length_ = 0u;
  clear_has_data_length();
}
inline ::google::protobuf::uint32 InstallOperation::data_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_length)
  return data_length_;
}
inline void InstallOperation::set_data_length(::google::protobuf::uint32 value) {
  set_has_data_length();
  data_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_length)
}

// repeated .chromeos_update_engine.Extent src_extents = 4;
inline int InstallOperation::src_extents_size() const {
  return src_extents_.size();
}
inline void InstallOperation::clear_src_extents() {
  src_extents_.Clear();
}
inline const ::chromeos_update_engine::Extent& InstallOperation::src_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_src_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Mutable(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_src_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_src_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.src_extents)
  return &src_extents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::src_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.src_extents)
  return src_extents_;
}

// optional uint64 src_length = 5;
inline bool InstallOperation::has_src_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstallOperation::set_has_src_length() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstallOperation::clear_has_src_length() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstallOperation::clear_src_length() {
  src_length_ = GOOGLE_ULONGLONG(0);
  clear_has_src_length();
}
inline ::google::protobuf::uint64 InstallOperation::src_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_length)
  return src_length_;
}
inline void InstallOperation::set_src_length(::google::protobuf::uint64 value) {
  set_has_src_length();
  src_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_length)
}

// repeated .chromeos_update_engine.Extent dst_extents = 6;
inline int InstallOperation::dst_extents_size() const {
  return dst_extents_.size();
}
inline void InstallOperation::clear_dst_extents() {
  dst_extents_.Clear();
}
inline const ::chromeos_update_engine::Extent& InstallOperation::dst_extents(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Get(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::mutable_dst_extents(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Mutable(index);
}
inline ::chromeos_update_engine::Extent* InstallOperation::add_dst_extents() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >*
InstallOperation::mutable_dst_extents() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.InstallOperation.dst_extents)
  return &dst_extents_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Extent >&
InstallOperation::dst_extents() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.InstallOperation.dst_extents)
  return dst_extents_;
}

// optional uint64 dst_length = 7;
inline bool InstallOperation::has_dst_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstallOperation::set_has_dst_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstallOperation::clear_has_dst_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstallOperation::clear_dst_length() {
  dst_length_ = GOOGLE_ULONGLONG(0);
  clear_has_dst_length();
}
inline ::google::protobuf::uint64 InstallOperation::dst_length() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.dst_length)
  return dst_length_;
}
inline void InstallOperation::set_dst_length(::google::protobuf::uint64 value) {
  set_has_dst_length();
  dst_length_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.dst_length)
}

// optional bytes data_sha256_hash = 8;
inline bool InstallOperation::has_data_sha256_hash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstallOperation::set_has_data_sha256_hash() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstallOperation::clear_has_data_sha256_hash() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstallOperation::clear_data_sha256_hash() {
  data_sha256_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_sha256_hash();
}
inline const ::std::string& InstallOperation::data_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_data_sha256_hash(const ::std::string& value) {
  set_has_data_sha256_hash();
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(const char* value) {
  set_has_data_sha256_hash();
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline void InstallOperation::set_data_sha256_hash(const void* value, size_t size) {
  set_has_data_sha256_hash();
  data_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.data_sha256_hash)
}
inline ::std::string* InstallOperation::mutable_data_sha256_hash() {
  set_has_data_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.data_sha256_hash)
  return data_sha256_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallOperation::release_data_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.data_sha256_hash)
  clear_has_data_sha256_hash();
  return data_sha256_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_data_sha256_hash(::std::string* data_sha256_hash) {
  if (data_sha256_hash != NULL) {
    set_has_data_sha256_hash();
  } else {
    clear_has_data_sha256_hash();
  }
  data_sha256_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.data_sha256_hash)
}

// optional bytes src_sha256_hash = 9;
inline bool InstallOperation::has_src_sha256_hash() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstallOperation::set_has_src_sha256_hash() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstallOperation::clear_has_src_sha256_hash() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstallOperation::clear_src_sha256_hash() {
  src_sha256_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_sha256_hash();
}
inline const ::std::string& InstallOperation::src_sha256_hash() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_src_sha256_hash(const ::std::string& value) {
  set_has_src_sha256_hash();
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(const char* value) {
  set_has_src_sha256_hash();
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline void InstallOperation::set_src_sha256_hash(const void* value, size_t size) {
  set_has_src_sha256_hash();
  src_sha256_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.InstallOperation.src_sha256_hash)
}
inline ::std::string* InstallOperation::mutable_src_sha256_hash() {
  set_has_src_sha256_hash();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.InstallOperation.src_sha256_hash)
  return src_sha256_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InstallOperation::release_src_sha256_hash() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.InstallOperation.src_sha256_hash)
  clear_has_src_sha256_hash();
  return src_sha256_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InstallOperation::set_allocated_src_sha256_hash(::std::string* src_sha256_hash) {
  if (src_sha256_hash != NULL) {
    set_has_src_sha256_hash();
  } else {
    clear_has_src_sha256_hash();
  }
  src_sha256_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_sha256_hash);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.InstallOperation.src_sha256_hash)
}

// -------------------------------------------------------------------

// PartitionUpdate

// required string partition_name = 1;
inline bool PartitionUpdate::has_partition_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionUpdate::set_has_partition_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionUpdate::clear_has_partition_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionUpdate::clear_partition_name() {
  partition_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_partition_name();
}
inline const ::std::string& PartitionUpdate::partition_name() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_partition_name(const ::std::string& value) {
  set_has_partition_name();
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(const char* value) {
  set_has_partition_name();
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline void PartitionUpdate::set_partition_name(const char* value, size_t size) {
  set_has_partition_name();
  partition_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.partition_name)
}
inline ::std::string* PartitionUpdate::mutable_partition_name() {
  set_has_partition_name();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.partition_name)
  return partition_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_partition_name() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.partition_name)
  clear_has_partition_name();
  return partition_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_partition_name(::std::string* partition_name) {
  if (partition_name != NULL) {
    set_has_partition_name();
  } else {
    clear_has_partition_name();
  }
  partition_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_name);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.partition_name)
}

// optional bool run_postinstall = 2;
inline bool PartitionUpdate::has_run_postinstall() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionUpdate::set_has_run_postinstall() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionUpdate::clear_has_run_postinstall() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionUpdate::clear_run_postinstall() {
  run_postinstall_ = false;
  clear_has_run_postinstall();
}
inline bool PartitionUpdate::run_postinstall() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.run_postinstall)
  return run_postinstall_;
}
inline void PartitionUpdate::set_run_postinstall(bool value) {
  set_has_run_postinstall();
  run_postinstall_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.run_postinstall)
}

// optional string postinstall_path = 3;
inline bool PartitionUpdate::has_postinstall_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionUpdate::set_has_postinstall_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartitionUpdate::clear_has_postinstall_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartitionUpdate::clear_postinstall_path() {
  postinstall_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_postinstall_path();
}
inline const ::std::string& PartitionUpdate::postinstall_path() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_postinstall_path(const ::std::string& value) {
  set_has_postinstall_path();
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(const char* value) {
  set_has_postinstall_path();
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline void PartitionUpdate::set_postinstall_path(const char* value, size_t size) {
  set_has_postinstall_path();
  postinstall_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.postinstall_path)
}
inline ::std::string* PartitionUpdate::mutable_postinstall_path() {
  set_has_postinstall_path();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.postinstall_path)
  return postinstall_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_postinstall_path() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.postinstall_path)
  clear_has_postinstall_path();
  return postinstall_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_postinstall_path(::std::string* postinstall_path) {
  if (postinstall_path != NULL) {
    set_has_postinstall_path();
  } else {
    clear_has_postinstall_path();
  }
  postinstall_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), postinstall_path);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.postinstall_path)
}

// optional string filesystem_type = 4;
inline bool PartitionUpdate::has_filesystem_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitionUpdate::set_has_filesystem_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PartitionUpdate::clear_has_filesystem_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PartitionUpdate::clear_filesystem_type() {
  filesystem_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filesystem_type();
}
inline const ::std::string& PartitionUpdate::filesystem_type() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_filesystem_type(const ::std::string& value) {
  set_has_filesystem_type();
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(const char* value) {
  set_has_filesystem_type();
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline void PartitionUpdate::set_filesystem_type(const char* value, size_t size) {
  set_has_filesystem_type();
  filesystem_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chromeos_update_engine.PartitionUpdate.filesystem_type)
}
inline ::std::string* PartitionUpdate::mutable_filesystem_type() {
  set_has_filesystem_type();
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.filesystem_type)
  return filesystem_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionUpdate::release_filesystem_type() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.filesystem_type)
  clear_has_filesystem_type();
  return filesystem_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionUpdate::set_allocated_filesystem_type(::std::string* filesystem_type) {
  if (filesystem_type != NULL) {
    set_has_filesystem_type();
  } else {
    clear_has_filesystem_type();
  }
  filesystem_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filesystem_type);
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.filesystem_type)
}

// repeated .chromeos_update_engine.Signatures.Signature new_partition_signature = 5;
inline int PartitionUpdate::new_partition_signature_size() const {
  return new_partition_signature_.size();
}
inline void PartitionUpdate::clear_new_partition_signature() {
  new_partition_signature_.Clear();
}
inline const ::chromeos_update_engine::Signatures_Signature& PartitionUpdate::new_partition_signature(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Get(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::mutable_new_partition_signature(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Mutable(index);
}
inline ::chromeos_update_engine::Signatures_Signature* PartitionUpdate::add_new_partition_signature() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >*
PartitionUpdate::mutable_new_partition_signature() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return &new_partition_signature_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::Signatures_Signature >&
PartitionUpdate::new_partition_signature() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.new_partition_signature)
  return new_partition_signature_;
}

// optional .chromeos_update_engine.PartitionInfo old_partition_info = 6;
inline bool PartitionUpdate::has_old_partition_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PartitionUpdate::set_has_old_partition_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PartitionUpdate::clear_has_old_partition_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PartitionUpdate::clear_old_partition_info() {
  if (old_partition_info_ != NULL) old_partition_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_old_partition_info();
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::old_partition_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.old_partition_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return old_partition_info_ != NULL ? *old_partition_info_ : *default_instance().old_partition_info_;
#else
  return old_partition_info_ != NULL ? *old_partition_info_ : *default_instance_->old_partition_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_old_partition_info() {
  set_has_old_partition_info();
  if (old_partition_info_ == NULL) {
    old_partition_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.old_partition_info)
  return old_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_old_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.old_partition_info)
  clear_has_old_partition_info();
  ::chromeos_update_engine::PartitionInfo* temp = old_partition_info_;
  old_partition_info_ = NULL;
  return temp;
}
inline void PartitionUpdate::set_allocated_old_partition_info(::chromeos_update_engine::PartitionInfo* old_partition_info) {
  delete old_partition_info_;
  old_partition_info_ = old_partition_info;
  if (old_partition_info) {
    set_has_old_partition_info();
  } else {
    clear_has_old_partition_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.old_partition_info)
}

// optional .chromeos_update_engine.PartitionInfo new_partition_info = 7;
inline bool PartitionUpdate::has_new_partition_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PartitionUpdate::set_has_new_partition_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PartitionUpdate::clear_has_new_partition_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PartitionUpdate::clear_new_partition_info() {
  if (new_partition_info_ != NULL) new_partition_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_new_partition_info();
}
inline const ::chromeos_update_engine::PartitionInfo& PartitionUpdate::new_partition_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.new_partition_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_partition_info_ != NULL ? *new_partition_info_ : *default_instance().new_partition_info_;
#else
  return new_partition_info_ != NULL ? *new_partition_info_ : *default_instance_->new_partition_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::mutable_new_partition_info() {
  set_has_new_partition_info();
  if (new_partition_info_ == NULL) {
    new_partition_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.new_partition_info)
  return new_partition_info_;
}
inline ::chromeos_update_engine::PartitionInfo* PartitionUpdate::release_new_partition_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.PartitionUpdate.new_partition_info)
  clear_has_new_partition_info();
  ::chromeos_update_engine::PartitionInfo* temp = new_partition_info_;
  new_partition_info_ = NULL;
  return temp;
}
inline void PartitionUpdate::set_allocated_new_partition_info(::chromeos_update_engine::PartitionInfo* new_partition_info) {
  delete new_partition_info_;
  new_partition_info_ = new_partition_info;
  if (new_partition_info) {
    set_has_new_partition_info();
  } else {
    clear_has_new_partition_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.PartitionUpdate.new_partition_info)
}

// repeated .chromeos_update_engine.InstallOperation operations = 8;
inline int PartitionUpdate::operations_size() const {
  return operations_.size();
}
inline void PartitionUpdate::clear_operations() {
  operations_.Clear();
}
inline const ::chromeos_update_engine::InstallOperation& PartitionUpdate::operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Mutable(index);
}
inline ::chromeos_update_engine::InstallOperation* PartitionUpdate::add_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.PartitionUpdate.operations)
  return operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
PartitionUpdate::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.PartitionUpdate.operations)
  return &operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
PartitionUpdate::operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.PartitionUpdate.operations)
  return operations_;
}

// optional bool postinstall_optional = 9;
inline bool PartitionUpdate::has_postinstall_optional() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PartitionUpdate::set_has_postinstall_optional() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PartitionUpdate::clear_has_postinstall_optional() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PartitionUpdate::clear_postinstall_optional() {
  postinstall_optional_ = false;
  clear_has_postinstall_optional();
}
inline bool PartitionUpdate::postinstall_optional() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.PartitionUpdate.postinstall_optional)
  return postinstall_optional_;
}
inline void PartitionUpdate::set_postinstall_optional(bool value) {
  set_has_postinstall_optional();
  postinstall_optional_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.PartitionUpdate.postinstall_optional)
}

// -------------------------------------------------------------------

// DeltaArchiveManifest

// repeated .chromeos_update_engine.InstallOperation install_operations = 1;
inline int DeltaArchiveManifest::install_operations_size() const {
  return install_operations_.size();
}
inline void DeltaArchiveManifest::clear_install_operations() {
  install_operations_.Clear();
}
inline const ::chromeos_update_engine::InstallOperation& DeltaArchiveManifest::install_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::mutable_install_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Mutable(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::add_install_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
DeltaArchiveManifest::mutable_install_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return &install_operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
DeltaArchiveManifest::install_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.install_operations)
  return install_operations_;
}

// repeated .chromeos_update_engine.InstallOperation kernel_install_operations = 2;
inline int DeltaArchiveManifest::kernel_install_operations_size() const {
  return kernel_install_operations_.size();
}
inline void DeltaArchiveManifest::clear_kernel_install_operations() {
  kernel_install_operations_.Clear();
}
inline const ::chromeos_update_engine::InstallOperation& DeltaArchiveManifest::kernel_install_operations(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Get(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::mutable_kernel_install_operations(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Mutable(index);
}
inline ::chromeos_update_engine::InstallOperation* DeltaArchiveManifest::add_kernel_install_operations() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >*
DeltaArchiveManifest::mutable_kernel_install_operations() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return &kernel_install_operations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::InstallOperation >&
DeltaArchiveManifest::kernel_install_operations() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.kernel_install_operations)
  return kernel_install_operations_;
}

// optional uint32 block_size = 3 [default = 4096];
inline bool DeltaArchiveManifest::has_block_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeltaArchiveManifest::set_has_block_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeltaArchiveManifest::clear_has_block_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeltaArchiveManifest::clear_block_size() {
  block_size_ = 4096u;
  clear_has_block_size();
}
inline ::google::protobuf::uint32 DeltaArchiveManifest::block_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.block_size)
  return block_size_;
}
inline void DeltaArchiveManifest::set_block_size(::google::protobuf::uint32 value) {
  set_has_block_size();
  block_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.block_size)
}

// optional uint64 signatures_offset = 4;
inline bool DeltaArchiveManifest::has_signatures_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeltaArchiveManifest::set_has_signatures_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeltaArchiveManifest::clear_has_signatures_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeltaArchiveManifest::clear_signatures_offset() {
  signatures_offset_ = GOOGLE_ULONGLONG(0);
  clear_has_signatures_offset();
}
inline ::google::protobuf::uint64 DeltaArchiveManifest::signatures_offset() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
  return signatures_offset_;
}
inline void DeltaArchiveManifest::set_signatures_offset(::google::protobuf::uint64 value) {
  set_has_signatures_offset();
  signatures_offset_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_offset)
}

// optional uint64 signatures_size = 5;
inline bool DeltaArchiveManifest::has_signatures_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeltaArchiveManifest::set_has_signatures_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeltaArchiveManifest::clear_has_signatures_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeltaArchiveManifest::clear_signatures_size() {
  signatures_size_ = GOOGLE_ULONGLONG(0);
  clear_has_signatures_size();
}
inline ::google::protobuf::uint64 DeltaArchiveManifest::signatures_size() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
  return signatures_size_;
}
inline void DeltaArchiveManifest::set_signatures_size(::google::protobuf::uint64 value) {
  set_has_signatures_size();
  signatures_size_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.signatures_size)
}

// optional .chromeos_update_engine.PartitionInfo old_kernel_info = 6;
inline bool DeltaArchiveManifest::has_old_kernel_info() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeltaArchiveManifest::set_has_old_kernel_info() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeltaArchiveManifest::clear_has_old_kernel_info() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeltaArchiveManifest::clear_old_kernel_info() {
  if (old_kernel_info_ != NULL) old_kernel_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_old_kernel_info();
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::old_kernel_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return old_kernel_info_ != NULL ? *old_kernel_info_ : *default_instance().old_kernel_info_;
#else
  return old_kernel_info_ != NULL ? *old_kernel_info_ : *default_instance_->old_kernel_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_old_kernel_info() {
  set_has_old_kernel_info();
  if (old_kernel_info_ == NULL) {
    old_kernel_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
  return old_kernel_info_;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_old_kernel_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
  clear_has_old_kernel_info();
  ::chromeos_update_engine::PartitionInfo* temp = old_kernel_info_;
  old_kernel_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_old_kernel_info(::chromeos_update_engine::PartitionInfo* old_kernel_info) {
  delete old_kernel_info_;
  old_kernel_info_ = old_kernel_info;
  if (old_kernel_info) {
    set_has_old_kernel_info();
  } else {
    clear_has_old_kernel_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_kernel_info)
}

// optional .chromeos_update_engine.PartitionInfo new_kernel_info = 7;
inline bool DeltaArchiveManifest::has_new_kernel_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeltaArchiveManifest::set_has_new_kernel_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeltaArchiveManifest::clear_has_new_kernel_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeltaArchiveManifest::clear_new_kernel_info() {
  if (new_kernel_info_ != NULL) new_kernel_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_new_kernel_info();
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::new_kernel_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_kernel_info_ != NULL ? *new_kernel_info_ : *default_instance().new_kernel_info_;
#else
  return new_kernel_info_ != NULL ? *new_kernel_info_ : *default_instance_->new_kernel_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_new_kernel_info() {
  set_has_new_kernel_info();
  if (new_kernel_info_ == NULL) {
    new_kernel_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
  return new_kernel_info_;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_new_kernel_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
  clear_has_new_kernel_info();
  ::chromeos_update_engine::PartitionInfo* temp = new_kernel_info_;
  new_kernel_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_new_kernel_info(::chromeos_update_engine::PartitionInfo* new_kernel_info) {
  delete new_kernel_info_;
  new_kernel_info_ = new_kernel_info;
  if (new_kernel_info) {
    set_has_new_kernel_info();
  } else {
    clear_has_new_kernel_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_kernel_info)
}

// optional .chromeos_update_engine.PartitionInfo old_rootfs_info = 8;
inline bool DeltaArchiveManifest::has_old_rootfs_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeltaArchiveManifest::set_has_old_rootfs_info() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeltaArchiveManifest::clear_has_old_rootfs_info() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeltaArchiveManifest::clear_old_rootfs_info() {
  if (old_rootfs_info_ != NULL) old_rootfs_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_old_rootfs_info();
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::old_rootfs_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return old_rootfs_info_ != NULL ? *old_rootfs_info_ : *default_instance().old_rootfs_info_;
#else
  return old_rootfs_info_ != NULL ? *old_rootfs_info_ : *default_instance_->old_rootfs_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_old_rootfs_info() {
  set_has_old_rootfs_info();
  if (old_rootfs_info_ == NULL) {
    old_rootfs_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
  return old_rootfs_info_;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_old_rootfs_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
  clear_has_old_rootfs_info();
  ::chromeos_update_engine::PartitionInfo* temp = old_rootfs_info_;
  old_rootfs_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_old_rootfs_info(::chromeos_update_engine::PartitionInfo* old_rootfs_info) {
  delete old_rootfs_info_;
  old_rootfs_info_ = old_rootfs_info;
  if (old_rootfs_info) {
    set_has_old_rootfs_info();
  } else {
    clear_has_old_rootfs_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_rootfs_info)
}

// optional .chromeos_update_engine.PartitionInfo new_rootfs_info = 9;
inline bool DeltaArchiveManifest::has_new_rootfs_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeltaArchiveManifest::set_has_new_rootfs_info() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeltaArchiveManifest::clear_has_new_rootfs_info() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeltaArchiveManifest::clear_new_rootfs_info() {
  if (new_rootfs_info_ != NULL) new_rootfs_info_->::chromeos_update_engine::PartitionInfo::Clear();
  clear_has_new_rootfs_info();
}
inline const ::chromeos_update_engine::PartitionInfo& DeltaArchiveManifest::new_rootfs_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_rootfs_info_ != NULL ? *new_rootfs_info_ : *default_instance().new_rootfs_info_;
#else
  return new_rootfs_info_ != NULL ? *new_rootfs_info_ : *default_instance_->new_rootfs_info_;
#endif
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::mutable_new_rootfs_info() {
  set_has_new_rootfs_info();
  if (new_rootfs_info_ == NULL) {
    new_rootfs_info_ = new ::chromeos_update_engine::PartitionInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
  return new_rootfs_info_;
}
inline ::chromeos_update_engine::PartitionInfo* DeltaArchiveManifest::release_new_rootfs_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
  clear_has_new_rootfs_info();
  ::chromeos_update_engine::PartitionInfo* temp = new_rootfs_info_;
  new_rootfs_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_new_rootfs_info(::chromeos_update_engine::PartitionInfo* new_rootfs_info) {
  delete new_rootfs_info_;
  new_rootfs_info_ = new_rootfs_info;
  if (new_rootfs_info) {
    set_has_new_rootfs_info();
  } else {
    clear_has_new_rootfs_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_rootfs_info)
}

// optional .chromeos_update_engine.ImageInfo old_image_info = 10;
inline bool DeltaArchiveManifest::has_old_image_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DeltaArchiveManifest::set_has_old_image_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DeltaArchiveManifest::clear_has_old_image_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DeltaArchiveManifest::clear_old_image_info() {
  if (old_image_info_ != NULL) old_image_info_->::chromeos_update_engine::ImageInfo::Clear();
  clear_has_old_image_info();
}
inline const ::chromeos_update_engine::ImageInfo& DeltaArchiveManifest::old_image_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return old_image_info_ != NULL ? *old_image_info_ : *default_instance().old_image_info_;
#else
  return old_image_info_ != NULL ? *old_image_info_ : *default_instance_->old_image_info_;
#endif
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::mutable_old_image_info() {
  set_has_old_image_info();
  if (old_image_info_ == NULL) {
    old_image_info_ = new ::chromeos_update_engine::ImageInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
  return old_image_info_;
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::release_old_image_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
  clear_has_old_image_info();
  ::chromeos_update_engine::ImageInfo* temp = old_image_info_;
  old_image_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_old_image_info(::chromeos_update_engine::ImageInfo* old_image_info) {
  delete old_image_info_;
  old_image_info_ = old_image_info;
  if (old_image_info) {
    set_has_old_image_info();
  } else {
    clear_has_old_image_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.old_image_info)
}

// optional .chromeos_update_engine.ImageInfo new_image_info = 11;
inline bool DeltaArchiveManifest::has_new_image_info() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DeltaArchiveManifest::set_has_new_image_info() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DeltaArchiveManifest::clear_has_new_image_info() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DeltaArchiveManifest::clear_new_image_info() {
  if (new_image_info_ != NULL) new_image_info_->::chromeos_update_engine::ImageInfo::Clear();
  clear_has_new_image_info();
}
inline const ::chromeos_update_engine::ImageInfo& DeltaArchiveManifest::new_image_info() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_image_info_ != NULL ? *new_image_info_ : *default_instance().new_image_info_;
#else
  return new_image_info_ != NULL ? *new_image_info_ : *default_instance_->new_image_info_;
#endif
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::mutable_new_image_info() {
  set_has_new_image_info();
  if (new_image_info_ == NULL) {
    new_image_info_ = new ::chromeos_update_engine::ImageInfo;
  }
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
  return new_image_info_;
}
inline ::chromeos_update_engine::ImageInfo* DeltaArchiveManifest::release_new_image_info() {
  // @@protoc_insertion_point(field_release:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
  clear_has_new_image_info();
  ::chromeos_update_engine::ImageInfo* temp = new_image_info_;
  new_image_info_ = NULL;
  return temp;
}
inline void DeltaArchiveManifest::set_allocated_new_image_info(::chromeos_update_engine::ImageInfo* new_image_info) {
  delete new_image_info_;
  new_image_info_ = new_image_info;
  if (new_image_info) {
    set_has_new_image_info();
  } else {
    clear_has_new_image_info();
  }
  // @@protoc_insertion_point(field_set_allocated:chromeos_update_engine.DeltaArchiveManifest.new_image_info)
}

// optional uint32 minor_version = 12 [default = 0];
inline bool DeltaArchiveManifest::has_minor_version() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DeltaArchiveManifest::set_has_minor_version() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DeltaArchiveManifest::clear_has_minor_version() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DeltaArchiveManifest::clear_minor_version() {
  minor_version_ = 0u;
  clear_has_minor_version();
}
inline ::google::protobuf::uint32 DeltaArchiveManifest::minor_version() const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.minor_version)
  return minor_version_;
}
inline void DeltaArchiveManifest::set_minor_version(::google::protobuf::uint32 value) {
  set_has_minor_version();
  minor_version_ = value;
  // @@protoc_insertion_point(field_set:chromeos_update_engine.DeltaArchiveManifest.minor_version)
}

// repeated .chromeos_update_engine.PartitionUpdate partitions = 13;
inline int DeltaArchiveManifest::partitions_size() const {
  return partitions_.size();
}
inline void DeltaArchiveManifest::clear_partitions() {
  partitions_.Clear();
}
inline const ::chromeos_update_engine::PartitionUpdate& DeltaArchiveManifest::partitions(int index) const {
  // @@protoc_insertion_point(field_get:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Get(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::mutable_partitions(int index) {
  // @@protoc_insertion_point(field_mutable:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Mutable(index);
}
inline ::chromeos_update_engine::PartitionUpdate* DeltaArchiveManifest::add_partitions() {
  // @@protoc_insertion_point(field_add:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >*
DeltaArchiveManifest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return &partitions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::chromeos_update_engine::PartitionUpdate >&
DeltaArchiveManifest::partitions() const {
  // @@protoc_insertion_point(field_list:chromeos_update_engine.DeltaArchiveManifest.partitions)
  return partitions_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chromeos_update_engine

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::chromeos_update_engine::InstallOperation_Type> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_update_5fmetadata_2eproto__INCLUDED
